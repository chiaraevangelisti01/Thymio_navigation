import numpy as np
import pyvisgraph as vg
from shapely.geometry import Polygon, Point, LineString
from scipy.interpolate import CubicSpline, make_interp_spline, make_smoothing_spline, splrep
import numpy as np
import matplotlib.pyplot as plt
import geopandas as gpd
from geopandas import GeoSeries

#-----------------------------------------------------LOCAL--------------------------------------------------------------
def potential_field_map(self, geo_env, goal_pos):
    potential_map = np.zeros_like(self.X)

    for i in range(len(self.x_range)):
        for j in range(len(self.y_range)):
            current_point = Point(self.x_range[i], self.y_range[j])
            att_force = self.k_att * np.array([goal_pos[0] - current_point.x, goal_pos[1] - current_point.y])

            rep_force = np.zeros(2)
            for obstacle in geo_env:
                distance = current_point.distance(obstacle)
                if distance < self.rep_radius:
                    if int(distance) != 0:
                        rep_force += self.k_rep * ((1 / distance - 1 / self.rep_radius) / distance**2) * np.array([current_point.x - obstacle.centroid.x, current_point.y - obstacle.centroid.y])

            total_force = att_force + rep_force
            potential_map[j, i] = np.linalg.norm(total_force)
    return potential_map

def plot_potential_map_arrows(self, potential_map, goal_pos):
    rows, cols = potential_map.shape
    x_range = np.linspace(0, cols - 1, cols)
    y_range = np.linspace(0, rows - 1, rows)
    X, Y = np.meshgrid(x_range, y_range)
    gradient_x = np.gradient(potential_map, axis=1)
    gradient_y = np.gradient(potential_map, axis=0)
    arrow_magnitudes = np.sqrt(gradient_x**2 + gradient_y**2)
    arrow_directions_x = gradient_x / arrow_magnitudes
    arrow_directions_y = gradient_y / arrow_magnitudes
    plt.figure(figsize=(20, 10))
    plt.quiver(X, Y, -arrow_directions_x, -arrow_directions_y, scale=5, color='r', scale_units='inches', width=0.005)
    plt.scatter(goal_pos[0], goal_pos[1], c='g', marker='o', label='Goal')
    plt.xlabel('X-axis')
    plt.ylabel('Y-axis')
    plt.legend()
    plt.show()

def plot_potential_map_arrows_on_geoseries(self, potential_map, geo_env, goal_pos):
    rows, cols = potential_map.shape
    x_range = np.linspace(0, cols - 1, cols)
    y_range = np.linspace(0, rows - 1, rows)
    X, Y = np.meshgrid(x_range, y_range)
    gradient_x = np.gradient(potential_map, axis=1)
    gradient_y = np.gradient(potential_map, axis=0)
    arrow_magnitudes = np.sqrt(gradient_x**2 + gradient_y**2)
    arrow_directions_x = gradient_x / arrow_magnitudes
    arrow_directions_y = gradient_y / arrow_magnitudes
    plt.figure(figsize=(20, 10))
    geo_env.plot(facecolor='none', edgecolor='k')
    plt.quiver(X, Y, -arrow_directions_x, -arrow_directions_y, scale=20, color='r', scale_units='inches', width=0.005)
    plt.scatter(goal_pos[0], goal_pos[1], c='g', marker='o', label='Goal')
    plt.xlabel('X-axis')
    plt.ylabel('Y-axis')
    plt.legend()
    plt.show()

def calculate_single_repulsive_potential(self, obstacle_position):
    repulsive_potential = self.k_rep / ((self.X - obstacle_position[0])**2 + (self.Y - obstacle_position[1])**2 + self.epsilon)
    repulsive_potential *= np.exp(-0.5 * ((self.X - obstacle_position[0])**2 + (self.Y - obstacle_position[1])**2) / self.robot_radius**2)
    return repulsive_potential

def potential_field_temp(self, robot_position):
    '''
    Inputs: robot position as a tuple with x and y coordinates, sensor readings, robot angle, delta angle indicating the deviation of right of left sensors from the center in degrees,map size as a tuple
            of x and y dimensions, tolerance on the sensor values to trigger the repulsion, scale factor to translate sensor value into distance in the map, k_rep defining the intensity of the repuslive force
    Outputs: potential field generated by the sensed obstacle as a matrix
    '''
    x_range = np.linspace(0, self.map_size[0], self.map_size[0])
    y_range = np.linspace(0, self.map_size[1], self.map_size[1])
    X, Y = np.meshgrid(x_range, y_range)
    
    repulsive_potential = np.zeros_like(X)

    #I condiser multiple sensors altoghether becasue I though this would me more smoooth, but we can try it out and see what happens
    #Sensing obstacle to the left
    if sum(self.prox_sensor_readings[0:3])> 3*self.tol:
        # Calculate the position of the obstacle in polar coordinates
        obstacle_distance = sum(self.prox_sensor_readings[0:2])/self.scale_factor #we need to find this factor experimentally
        obstacle_angle = np.radians(self.robot_angle + self.delta_angle)
    
    #Sensing obstacle to the right
    elif sum(self.prox_sensor_readings[1:4])> 3*self.tol:
        # Calculate the position of the obstacle in polar coordinates
        obstacle_distance = sum(self.prox_sensor_readings[1:3])/self.scale_factor #we need to find this factor experimentally
        obstacle_angle = np.radians(self.robot_angle)

    #Sensing obstacle to the front
    elif sum(self.prox_sensor_readings[3:6])> 3*self.tol:
        # Calculate the position of the obstacle in polar coordinates
        obstacle_distance = sum(self.prox_sensor_readings[3:5])/self.scale_factor #we need to find this factor experimentally
        obstacle_angle = np.radians(self.robot_angle - self.delta_angle)
    
    else:
        obstacle_distance = 0

    if obstacle_distance!=0:
        #Calculate the obstacle position in map coordinates 
        obstacle_x = robot_position[0] + obstacle_distance * np.cos(obstacle_angle)
        obstacle_y = robot_position[1] + obstacle_distance * np.sin(obstacle_angle)

        if 0 <obstacle_x < self.map_size[0] and  0<obstacle_y< self.map_size[1]:

            # Calculate the repulsive potential field for the obstacle
            repulsive_potential += calculate_single_repulsive_potential(X, Y, [obstacle_x, obstacle_y], self.k_rep, self.robot_radius)

    return repulsive_potential

def calculate_total_potential(self, potential_map, repulsive_potential):
    total_potential = potential_map + repulsive_potential
    return total_potential

def compute_gradient(self, x, y, overall_map):
    df_dx = (overall_map[x + self.epsilon, y] - overall_map[x - self.epsilon, y]) 
    df_dy = (overall_map[x, y + self.epsilon] - overall_map[x, y - self.epsilon]) 
    return np.array([df_dx, df_dy])

def find_next_position(self, robot_position, overall_map):

    gradient = self.compute_gradient(robot_position[0], robot_position[1], overall_map)
    direction = gradient / np.linalg.norm(gradient)
    next_point = robot_position + self.step_size * direction
    return next_point

# local navigation function with condition about fixed or changed environment
def local_navigation(self, geo_env, robot_position, goal_pos):
    
    potential_map = self.potential_field_map(geo_env, goal_pos)
    repulsive_potential = self.potential_field_temp(robot_position)
    total_potential = self.calculate_total_potential(potential_map, repulsive_potential)
    next_point = self.find_next_position(robot_position, total_potential)

    return next_point

#-----------------------------------------------------GLOBAL-----------------------------------------------------
def create_polygons(self, list_coordinates):
    '''
    Input: array of tuples of obstackle corners in xy coordinate system: SORTED
    Output: array of obstacles as polygon data structure
    '''

    polygons = []

    for cor in list_coordinates:
        polygons.append(Polygon(cor))

    return polygons

def create_environment(self, polygons):
    '''
    Input: array of obstacles as polygon data structure
    Output: geoseries of obstacles
    '''

    environment = gpd.GeoSeries(polygons)

    return environment

def dilate_obstacles(self, environment):
    '''
    Input: geoseries of obstacles, robot radius
    Output: geoseries of obstacles dilated by the robot radius
    '''

    dilated_environment = environment.buffer(join_style=2)

    return dilated_environment

def extract_coordinates(self, environment):
    ''' 
    Input: geoseries environement made of polygons
    Output: array of tuples of obstacle corners in xy coordinate system
    '''

    list_coordinates = []

    for pol in environment:
        x,y = pol.exterior.coords.xy
        
        list_coordinates.append(list(zip(x, y)))
    
    return list_coordinates

def create_vs_graph(self, list_coordinates):
    '''
    Input: array of tuples of obstacle corners in xy coordinate system
    Output: Visibilty Graph object
    '''

    vg_obstacles = []

    for set in list_coordinates:
        
        pol = []
        
        for el in set:
            pol.append(vg.Point(el[0],el[1]))
        
        vg_obstacles.append(pol)
    
    graph = vg.VisGraph()
    vis_gr = graph.build(vg_obstacles)

    return vis_gr

def shortest_path(self, vg_graph, start, goal):
    '''
    Input: array of vg.Points of obstacle corners, vg.Point of start, vg.Point of goal
    Output: array of vg.Points of the shortest path
    '''
    start_vg = vg.Point(start[0],start[1])
    goal_vg = vg.Point(goal[0],goal[1])
    # Find the shortest path
    vs_path = vg_graph.shortest_path(start_vg, goal_vg)

    return vs_path

def convert_path_vs(self, vs_path):
    '''
    Input: array of points in vs format constituting the shortest path 
    Output  array of points in shapely structure, array of tuples of path steps in xy coordinate system  
    '''
    path_gs = []
    path_tuples = []

    for el in vs_path:

        path_gs.append(Point(el.x,el.y))
        path_tuples.append((el.x,el.y))
    
    return path_gs, path_tuples

def smoothen_path(self, path_tuples, num_points):
    '''
    Inputs: array of tuples path steps in xy coordinate system
    Outputs. array of tuples of the steps of the smoothened path in xy coordinate system'''

    # Generate a finer set of points for a smoother curve
    x_points = path_tuples[:,0]
    x_finer = np.linspace(x_points[0], x_points[-1], num_points)  # Adjust the number of points as needed

    # Create an interpolated spline interpolation on the finer set of points
    spline_interp = make_interp_spline(path_tuples[:,0], path_tuples[:,1]) 

    # Obtain the corresponding y-coordinates on the smoothed curve
    y_finer_interp = spline_interp(x_finer)
    
    path = np.matrix.transpose(np.array([x_finer,y_finer_interp]))

    return path

def compute_num_points(self, path_tuples):
    '''
    Compute the number of points for smoothing depending on the distance from the goal
    '''

    #Calculate the distance: since they are straight line, the path lenght can be found through Pytagorean theorem between the points identified
    distance = 0

    for i in range(len(path_tuples)-1):
        distance += np.sqrt((path_tuples[i][0]-path_tuples[i+1][0])**2+(path_tuples[i][1]-path_tuples[i+1][1])**2)

    #Converte the distance to the number of points
    num_points = np.ceil(distance/(3*self.at_target_threshhold))

    return num_points

def plot_geoenv(self, plot_info):

    GeoSeries.plot(plot_info)

def plot_env_path(self, environment, dilated_environment, path):
    '''
    Plot the path and the dilated environment in a Geoseries environment
    '''

    ax1 = GeoSeries.plot(dilated_environment,color='red')
    GeoSeries.plot(environment,color='blue',ax=ax1)
    plt.plot(path[:,0],path[:,1],color='orange')
    plt.show()

# global navigation function with condition about fixed or changed environment
def global_navigation(self, list_coordinates, start, goal, changed_environment=False):
    '''
    Inputs: geoseries of obstacles, start position as tuple of x and y coordinates, goal position as tuple of x and y coordinates, robot radius, boolean indicating if the environment is fixed or not
    Outputs: array of tuples of the steps of the smoothened path in xy coordinate system
    '''
    if changed_environment:
        # Create polygons
        polygons = self.create_polygons(list_coordinates)

        # Create environment
        environment = self.create_environment(polygons)

        # Dilate environment
        dilated_environment = self.dilate_obstacles(environment)
        self.geo_env = dilated_environment

        # Extract coordinates
        list_coordinates = self.extract_coordinates(dilated_environment)

        # Convert to visibility graph
        vg_graph = self.create_vs_graph(list_coordinates)

    # Find shortest path
    vs_path = self.shortest_path(vg_graph, start, goal)

    # Convert path
    path_gs, path_tuples = self.convert_path_vs(vs_path)

    #Calculate the number of points in the path
    num_points = compute_num_points(self, path_tuples)

    # Smoothen path
    path = self.smoothen_path(path_tuples,num_points)

    #Plot the environment 
    plot_env_path(self, environment, dilated_environment, path)

    return path